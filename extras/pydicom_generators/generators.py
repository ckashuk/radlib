import logging
import os
import time
from argparse import Namespace
import numpy as np
from pathlib import Path
import pydicom
import pydicom.encaps
import tempfile

import SimpleITK as sitk

from radlib.dcm import check_for_valid_modality, dicom_modalities
from extras.dicom_standard_validation.spec_reader.edition_reader import EditionReader
from extras.dicom_standard_validation.validator import DicomFileValidator


def generate_valid_template_dcm(modality: str) -> pydicom.Dataset:
    """
    Uses functionalized code from pydicom codify utility to generate a "valid" dcm object

    Parameters
    ----------
    modality: str one of CT, PT, MR
        The modality to generate, has to have a "pydicom_generated_xx_master.py" generated by codify

    Returns
    -------
    a "valid" pydicom "dcm" object produced from code, that can be updated by adding/replacing tags

    TODO: 2024-12 csk handle missing PixelData attribute? could test_processor that size tags are valid
    """

    check_for_valid_modality(modality)

    ds = dicom_modalities[modality]['creator_function']()

    return ds

def generate_dcm_pydicom(modality: str,
                         pixel_data: np.ndarray=None,
                         tags=None,
                         origin = [0, 0, 0],
                         direction = [0, 0, 0, 0, 0, 0],
                         spacing = [1, 1, 1]):
    if tags is None:
        tags = {}

    slices = []

    # if 2d image, reshape to 3d image with one slice
    if len(pixel_data.shape) == 2:
        pixel_data = pixel_data.reshape(pixel_data.shape[0], pixel_data.shape[1], 1)

    # handle pixel_data
    if pixel_data is not None:
        slice_count = pixel_data.shape[2]
        for s in range(slice_count):
            slice_data = pixel_data[:, :, s]
            # slice_data = slice_data.astype(np.uint8)
            # first get a valid template_processor ds
            ds = generate_valid_template_dcm(modality)

            """
            # File meta info data elements
            file_meta = FileMetaDataset()
            file_meta.FileMetaInformationGroupLength = 200
            file_meta.FileMetaInformationVersion = b'\x00\x01'
            file_meta.MediaStorageSOPClassUID = '1.2.840.10008.5.1.4.1.1.7'
            file_meta.MediaStorageSOPInstanceUID = '1.2.276.0.7230010.3.1.4.165240133.21536.1734112512.319'
            # file_meta.TransferSyntaxUID = '1.2.840.10008.1.2.4.70'
            # file_meta.TransferSyntaxUID = pydicom.uid.ExplicitVRLittleEndian
            file_meta.ImplementationClassUID = '1.2.40.0.13.1.1.1'
            file_meta.ImplementationVersionName = 'dcm4che-1.4.37'
            """

            ds.Rows = pixel_data.shape[0]
            ds.Columns = pixel_data.shape[1]
            ds.file_meta.TransferSyntaxUID = '1.2.840.10008.1.2.4.57'
            ds.PixelData = pydicom.encaps.encapsulate([slice_data.tobytes()])
            ds.ImagePositionPatient = origin
            ds.ImageOrientationPatient = direction
            ds.SliceLocation = float(origin[2])
            ds.SliceThickness = float(spacing[2])
            ds.PixelSpacing = spacing[0:2]

            # replace tags:
            for tag, value in tags.items():
                # TODO: fix pydicom types!!
                ds[tag] = value
            slices.append(ds)

    return slices

dcmtk_folder = 'c://Users/CXK023/Documents/dcmtk-3.6.8-win64-dynamic/bin'

def generate_dcm_dcmtk(img_path: str, dcm_path: str):
    command = f"{dcmtk_folder}/img2dcm {img_path} {dcm_path} -sef {img_path}"
    os.system(command)
    dcm = pydicom.dcmread(dcm_path)
    return dcm

def validate_dcm(ds: pydicom.Dataset):
    """
    Validate that this is a usable pydicom Dataset, all required tags are present,
    size and position tags make sense, etc.

    Parameters
    ----------
    ds: a pydicom Dataset to be tested

    Returns
    -------
    list of issues found with the dataset, empty list if nothing found
    """

    # Create a temporary file
    temp_file = tempfile.NamedTemporaryFile(mode='w+b')
    pydicom.dcmwrite(f'{temp_file.file.name}.dcm', ds)

    # generate args
    args = Namespace(dicomfiles=[f'{temp_file.file.name}.dcm'],
                     standard_path=str(Path.home() / "dicom-validator"),
                     revision="current",
                     force_read=False,
                     recreate_json=False,
                     suppress_vr_warnings=False,
                     verbose=True)
    edition_reader = EditionReader(args.standard_path)
    base_path = edition_reader.get_revision(args.revision, args.recreate_json)
    json_path = Path(base_path, "json")
    dicom_info = EditionReader.load_dicom_info(json_path)
    log_level = logging.DEBUG if args.verbose else logging.INFO
    validator = DicomFileValidator(
        dicom_info, log_level, args.force_read, args.suppress_vr_warnings
    )
    error_nr = 0
    for dicom_path in args.dicomfiles:
        error_nr += sum(
            len(error) for error in list(validator.validate(dicom_path).values())
        )
    temp_file.close()
    return error_nr


def writeSlices(data_directory, series_tag_values, new_img, i):

    writer = sitk.ImageFileWriter()
    # Use the study/series/frame of reference information given in the meta-data
    # dictionary and not the automatically generated information from the file IO
    writer.KeepOriginalImageUIDOn()

    image_slice = new_img[:, :, i]
    # print(image_slice.GetPixelIDTypeAsString())
    #image_slice = sitk.Cast(image_slice, sitk.sitkInt16)
    # image_slice = sitk.Cast(image_slice, sitk.sitkFloat32)

    # Tags shared by the series.
    list(map(lambda tag_value: image_slice.SetMetaData(tag_value[0], tag_value[1]), series_tag_values))

    # Slice specific tags.
    image_slice.SetMetaData("0008|0012", time.strftime("%Y%m%d"))  # Instance Creation Date
    image_slice.SetMetaData("0008|0013", time.strftime("%H%M%S"))  # Instance Creation Time

    # Setting the type to CT preserves the slice location.
    image_slice.SetMetaData("0008|0060", "MR")

    # (0020, 0032) image position patient determines the 3D spacing between slices.
    image_slice.SetMetaData("0020|0032", '\\'.join(
        map(str, new_img.TransformIndexToPhysicalPoint((0, 0, i)))))  # Image Position (Patient)
    image_slice.SetMetaData("0020,0013", str(i))  # Instance Number

    # Write to the output directory and add the extension dcm, to force writing in DICOM format.
    writer.SetFileName(os.path.join(data_directory, str(i) + '.dcm'))
    writer.Execute(image_slice)


def generate_dcm_from_volume(volume, output_directory, ref_image=None, origin=None, spacing=None, direction=None, ):
    # 202501 csk code adapted from https://simpleitk.readthedocs.io/en/master/link_DicomSeriesFromArray_docs.html
    # Write the 3D image as a series
    # IMPORTANT: There are many DICOM tags that need to be updated when you modify an
    #            original image. This is a delicate opration and requires knowlege of
    #            the DICOM standard. This example only modifies some. For a more complete
    #            list of tags that need to be modified see:
    #                           http://gdcm.sourceforge.net/wiki/index.php/Writing_DICOM
    #            If it is critical for your work to generate valid DICOM files,
    #            It is recommended to use David Clunie's Dicom3tools to validate the files
    #                           (http://www.dclunie.com/dicom3tools.html).

    if ref_image is not None:
        if origin is None:
            origin = ref_image.GetOrigin()
        if spacing is None:
            spacing = ref_image.GetSpacing()
        if direction is None:
            direction = ref_image.GetDirection()
    if origin is None:
        origin = (0, 0, 0)
    if spacing is None:
        spacing = (1, 1, 1)
    if direction is None:
        direction = [1, 0, 0, 0, 1, 0, 0, 0, 1]


    new_img = sitk.GetImageFromArray(volume)
    new_img.SetOrigin(origin)
    new_img.SetSpacing(spacing)

    modification_time = time.strftime("%H%M%S")
    modification_date = time.strftime("%Y%m%d")

    # Copy some of the tags and add the relevant tags indicating the change.
    # For the series instance UID (0020|000e), each of the components is a number, cannot start
    # with zero, and separated by a '.' We create a unique series ID using the date and time.
    # tags of interest:
    # direction = new_img.GetDirection()
    series_tag_values = [("0008|0031", modification_time),  # Series Time
                         ("0008|0021", modification_date),  # Series Date
                         ("0008|0008", "DERIVED\\SECONDARY"),  # Image Type
                         ("0020|000e", "1.2.826.0.1.3680043.2.1125." + modification_date + ".1" + modification_time),
                         # Series Instance UID
                         ("0020|0037",
                          '\\'.join(map(str, (direction[0], direction[3], direction[6],  # Image Orientation (Patient)
                                              direction[1], direction[4], direction[7])))),
                         ("0008|103e", "Created-SimpleITK"),
                         ("0010|0020", "patientid"),  # patientID
                         ("0020|000d", "1.2.826.0.1.3680043.2.1125.1000"),  # study instance uid
                         ("0020|0010", '1000'),  # study id
                         ("0020|0011", '10000'),  # instance number
                         ]

    list(map(lambda i: writeSlices(output_directory, series_tag_values, new_img, i), range(new_img.GetDepth())))
